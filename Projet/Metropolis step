void Lattice::Metropolis_Step(Lattice& L, Matrix& Particles, const Matrix& InteractionMap, const double beta){

        std::uniform_int_distribution<int> RandomParticle(0, Particles.nx-1);
        int Particle_Number = RandomParticle(gen);
        Site s=L.site_xy(Particles(Particle_Number, 0), Particles(Particle_Number, 1));
    
        int Orientation = L[s];
        double DeltaE=0;

        //Calcul de la contribution du site s à l'énergie
        std::vector<int> EmptySites; //Liste contenant l'indice des sites vides (ds l'ordre trig)  
        Matrix FacesInitial = Contact_Faces(L,s, EmptySites);
        for(int i=0;i<6;i++){
            if (FacesInitial(i,0) >= 0){
                DeltaE-=InteractionMap(FacesInitial(i,0), FacesInitial(i,1));
            }
        }


        std::uniform_real_distribution<float> distribution(0, 1);
        float MoveOrSpin = distribution(gen);
    
        Site NewLocation = s;
        int NewOrientation = Orientation;


        if( (EmptySites.size() != 0) && (MoveOrSpin < 0.5) ){
            std::uniform_int_distribution<int> MoveWhere(0,EmptySites.size()-1);
            NewLocation = L.voisins(s)[EmptySites[MoveWhere(gen)]];
        
            L[s]=0;
            L[NewLocation] = Orientation;      
        }
        else{
            std::uniform_int_distribution<int> OrientationHow(1,5);
            NewOrientation = OrientationHow(gen);

        if( NewOrientation >= Orientation ){
            NewOrientation++;
        }

            L[s] = NewOrientation;
        }


        //Calcul de la contribution du spin modifié
        Matrix FacesFinal = Contact_Faces(L, NewLocation);
        for(int i=0;i<6;i++){
            if (FacesFinal(i,0) >= 0){
                DeltaE+=InteractionMap(FacesFinal(i,0), FacesFinal(i,1));
            }
        } 

        double ProbaAccept=exp(-beta*DeltaE);
    
        if (distribution(gen) < ProbaAccept){
            Particles(Particle_Number, 0) = NewLocation._x;
            Particles(Particle_Number, 1) = NewLocation._y;
        }
        else{
            L[NewLocation]=0;
            L[s]=Orientation;
            //On fait pas le changement
        }
}
